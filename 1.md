# 序言 什么是指令？如何用好指令？

本教程是`1.13`和`1.13.x`版本的指令教程，更低版本请另找对应的教程。

本教程主要参考`Minecraft Wiki`，欢迎大家指出错误和提出建议。

与其他教程不同的是，本教程提供的实例并不会太多，但是会尝试用一个自学者的角度去思考讲解的顺序，让大家在学习的过程中少走弯路。

什么是指令？例如`/gamemode creative`就是一条指令，`/give @p minecraft:diamond_sword{display:{Name:"{\"text\":\"大宝剑\"}"}} 1`也是一条指令。指令是通过指定**动作**和**参数**来实现特定功能的一个玩意儿。在正式学习指令之前，我们需要对一些基础的知识进行讲解。请大家对此表示耐心，因为弄懂这些以后，对后续进行系统性地学习和运用指令都会有巨大的帮助。

举个例子，很多人要做一个效果，上来就谈"检测"，而说到"检测"，很多人第一反应就是`/testfor`，可到最后却连实际想要的效果是什么都没搞清楚。我曾见过有个人提了这样一个问题：

> 如何检测一个人背包里有没有钻石块，有的话就清除掉，并告诉他"你被骗了"。

然后有人一看到"检测"二字就来神了……这个简单哇！

接着他就开始高谈阔论：

    /execute as @a[...] ...balabalabala

这就是典型的**连选择器的用法都没搞懂**的朋友。

对于这样一个题，可以这样做：

    title @a[nbt={Inventory:[{id:"minecraft:diamond_block"}]}] title "你被骗了！"
    clear @a[nbt={Inventory:[{id:"minecraft:diamond_block"}]}] diamond_block

其实，这个问题也没有提好，与其说是"检测"玩家背包里有没有某样东西，倒不如说是将这类玩家"筛选"出来。

`/testfor <targets>`的本质，不就是在使用**选择器**吗？

因此，我们真心希望看本教程的读者，能够从基础开始打牢，不要闹出这样的笑话来。

# 第一章 数据类型 \& 字符串

很多教程都是先讲坐标和选择器，本教程则是先从数据类型开始讲起。理由是后续有许多涉及到数据的地方，我们再插入讲解的话，会把前面讲过的部分又拿出来进行扩充，这样就是在走弯路了。因此我们从数据类型和字符串开始讲。

## 1. 数据类型

提到数据，最基本的两个单位是**位 (bit)** 和**字节 (byte)**。其中**数据传输**一般用**位**，而**数据储存**则用**字节**。Minecraft 中，基本的数据单位也从**字节**开始。

### &emsp;(1) Byte

`Byte`是有正负范围的整形数据类型，由于`1 字节 = 8 位`，因此`Byte`类型的数据，其取值范围是`-128`到`127`。\< 注：-(2<sup>7</sup>) ~ (2<sup>7</sup>-1) \>

对于`true`和`false`，一般用`1`和`0`来表示，因此 Minecraft 的`NBT`中通常用`1b`和`0b`来表示`true|false`。关于`NBT`的内容我们将在后面讲到。

### &emsp;(2) Short

`Short`是有正负范围的整形数据类型，它占用`2 字节`，因此`Short`类型的数据，其取值范围是`-32768`到`32767`。\< 注：-(2<sup>15`</sup>) ~ (2<sup>15</sup>-1) \>

### &emsp;(3) Int

`Short`是有正负范围的整形数据类型，它占用`4 字节`，因此`Int`类型的数据，其取值范围是`-2,147,483,648`到`2,147,483,647`。\< 注：-(2<sup>31`</sup>) ~ (2<sup>31</sup>-1) \>

### &emsp;(4) Long

`Long`是有正负范围的整形数据类型，它占用`8 字节`，因此`Long`类型的数据，其取值范围是`-9,223,372,036,854,775,808`到`9,223,372,036,854,775,807`。\< 注：-(2<sup>63`</sup>) ~ (2<sup>63</sup>-1) \>

### &emsp;(5) Float

`Float`是有正负的浮点数据类型，它占用`4 字节`，也就是我们通常说的**单精度浮点数**，在[IEEE 754-2008](https://zh.wikipedia.org/wiki/IEEE_754)中被正式称为**binary 32**格式。
通俗来说就是用来表示范围很大的数，包括小数。`Float`类型的数据，最大值约为**3.4\*10<sup>38</sup>**。

### &emsp;(6) Double

`Double`是有正负的浮点数据类型，他占用`8`字节，也就是我们通常说的**双精度浮点数**，在[IEEE 754-2008](https://zh.wikipedia.org/wiki/IEEE_754)中被正式称为**binary 64**格式。
其最大值约为**1.8\*10<sup>108</sup>**。<br>

很多朋友刚刚接触`NBT`的时候会觉得很难记数据类型，其实不难。数据存储的原则就是尽可能用少的字节去存储数据。比如上面说的`true|false`，它的取值就是`1|0`，不会再有其他的取值，这样的情况，当然会使用`Byte`而不是用占用空间更大的`Short`。对于**附魔等级**来说，由于**附魔等级**的最大值是`255`，因此它就不能再用`Byte`了，转而使用更高一级的`Short`。

## 2. 字符串

字符串叫做`string`，这里我们就不多说了，举个例子，`fuckingCBL`就是一个字符串。在`Raw JSON Text`中，所有的字符串都需要**双引号**括住。

这一章的内容需要一定的时间去消化，但是我们希望读者能慢慢去弄懂它们。我们在后面讲到的所有内容，都以此为基石。

# 第二章 指令等级 \& 指令格式

这一章我们讲一个指令，也是唯一一个在讲要素之前提到的指令，这个指令主要作用是查指令格式。

在游戏的聊天框中输入`/help`并回车，就可以查询到**当前可以执行的指令**的格式。为什么说是"可以执行的指令"呢？这就要涉及到**指令等级**了。

## 1. 指令等级

一般地，指令需要管理员才有权限执行，等级越高，可以执行的就越多。见下表。

> 1 - 管理员可以无视出生点保护（破坏与放置方块）。<br>
2 - 管理员可以使用`单机指令`和`命令方块指令`。领域服的管理员就是这个等级。<br>
3 - 在**2级管理员**的基础上，可以使用部分的`服务器指令`，如`/op`, `/debug`, `/ban`等。<br>
4 - 在**3级管理员**的基础上，可以使用`/stop`, `/save-all`, `/save-on`, `save-off`, `/reload`, `/chunk`<sup>1.13.1 新增</sup>。

更多有关`op等级`的内容，将会在后续讲解`服务器指令`的时候讲到。

## 2. 指令格式

前面说了，输入`/help`可以查看到**当前可以执行的指令**的格式。而如果你只是想查某个特定的指令，则可以输入`/help <command>`。

这里就开始讲到指令格式了。比如上面的`/help <command>`。这个`<command>`就指的是某个指令，如`/setblock`等。当然由于`/help`本身也是一个指令，因此你也可以输入`/help help`。你将会得到这样的反馈：

    /help [<command>]

像`<command>`这样用单书名号`<>`括住的都是指某个类型的参数。其他的例子有`<pos>`, `<target>`, `<targets>`等。

这里的中括号`[]`的意思是**既可以输入，也可以不输入**,解析成两条指令格式分别是

    /help
    /help <command>

再看看这样一条指令格式：

    /weather (clear|rain|thunder) [<duration>]

这里的`(a|b|c...)`就是指必须从`a`, `b`, `c`中选一个填写，`|`是分隔符的意思，把每个字符串隔开。上面这个格式可以解析成三条指令：

    /weather clear [<duration>]
    /weather rain [<duration>]
    /weather thunder [<duration>]

如果是可选的字符串参数，则会写成`[a|b|c...]`这样。如`/setblock <pos> <block> [destroy|keep|replace]`


当然，`help`会告诉你指令列表，它里面对于格式的讲解并不是最详细的，而`/help <command>`会帮你进行必要的格式解析，是详细的。

最后，再来看看这样的指令格式：

    /tp -> teleport

它的意思是，`/tp`是`/teleport`的简写，两者功能相同。<sup>注：这里要特别跟以前版本区分开来</sup>


## 3. 指令的构成

通过观察`/help`给出的列表，我们可以看到，指令概括起来可以分为两部分，一部分是`动作`，另一部分是`参数`。所以用我们上面的格式，一条指令看起来应该是这样的

    /<动作> [<参数A>] [<参数B>] ...

`<动作>`表明了这条指令的作用，`<参数>`则是表明指令的具体作用，参数越多，则越具体。在接下来的两章中，我们将讲到几个最基础的参数，这几个参数在绝大多数指令中都出现了，并且也是整个指令体系的基础，因此我们希望读者能耐心读完。

# 第三章 坐标 \& 朝向

从这一章起，我们将用两章的篇幅讲解两个参数，这些参数是许多指令中都会出现的。弄懂这些对于后续学习和运用指令会有巨大帮助。尤其是**指令的运用**<sup>见序章</sup>。

本章主要讲**坐标**。而**朝向**作为坐标的一个分支来讲。

坐标按照对象分，可以分为 **方块坐标**、**实体坐标**、**执行坐标**；

按照表示方法分，可以分为 **绝对坐标**、**相对坐标**、**本地坐标**；

按数据类型分，可以分为 **整形坐标**、**浮点坐标**。

这样一看，分类还挺多？但是这样子分类都是很片面的。所以这一段不用看，往下看就好。

坐标在指令格式中的参数表示是`<pos>`, `<x> <y> <z>`, `<center>`, `<x> <z>`等。

朝向在指令格式中的参数表示是`<rotation>`, `<y-rot> <x-rot>`等。

## 1. 世界坐标

可能会有人一脸懵逼，怎么刚讲完分类，你就给来了一个分类里没提到的东西？

其实，上面讲到的**绝对坐标**和**相对坐标**都属于**世界坐标**。世界坐标用来表示方块、实体、指令执行的位置。

世界坐标使用`<x> <y> <z>`三个坐标轴，其中`<x>`的正方向是**东**，`<z>`的正方向是**南**，`<y>`的正方向是**上**。

(1) 方块坐标

由于方块格的长度是`1`，因此方块的坐标是由一组**整数**来记录的。我们知道，Minecraft 中默认的世界边界在`30,000,000`，因此**方块坐标**的**数据类型**是`Int`。并且，方块坐标是唯一的**数据类型是`Int`的坐标**。

举个例子，如`/setblock <pos> <block> ...`中，`<pos>`既可以填写`绝对坐标`，也可以填`相对执行位置的坐标`。如果填的是`绝对坐标`，那么这里的`<pos>`就解析成`<x(Int)> <y(Int)> <z(Int)>`，也就是**三个Int型的整数组成**的`绝对坐标`。我们把这个绝对坐标，叫做`方块坐标`。

(2) 位置坐标

这里的位置坐标主要是指**实体的位置**或者**指令执行的位置**。我们知道，实体有两个重要的参数，一个是`中心点`，另一个是`碰撞箱`。这里的`中心点`就是指`实体位置`。

位置坐标的数据类型是`Double`。千万不要弄错了。

(3) 方块坐标与位置坐标的关系<sup>注：后面出现在`/execute`中的`方块对齐`就是指的这个玩意儿</sup>

假设某个点的坐标是`2.3 3.2 -2.3`，这个点对应的方块坐标就是`2 3 -3`。也就是说，**位置坐标通过向下取整得到方块坐标**。

而有的指令如`/tp`, `/summon`中，要求输入的是**位置坐标**，而玩家却输入了**方块坐标**，那么取点则是在该方块的`水平底面的中心点`。如`3 3 -3`就转换为`3.5 3.0 -2.5`。

## 2. 相对坐标和绝对坐标

在 Minecraft 中，如果在坐标中的数字前加上`~`，则表示这是一个相对坐标，相对的是**当前的指令执行位置**。例如`~1.5 ~ ~`表示**当前位置向东1.5格**。其中`~`等价于`~0`。

本质上所有坐标都是相对坐标。为什么这么说呢？因为绝对坐标就是相对于世界原点`0 0 0`的坐标哇！

像上面提到的`2.3 3.2 -2.3`就是绝对坐标。

绝对坐标和相对坐标是可以混用的，例如`~-2 .1 -2.3`<sup>这里的`.1`等价于`0.1`</sup>就是一个混用的例子。

## 3. 本地坐标

这里引入`^`表示本地坐标。某种意义上来说本地坐标也是相对的坐标，但是为了不混淆，这里应该和`相对坐标`区分开来。这个区别就是，`相对坐标`采用的是`世界坐标系`，即`<x> <y> <z>`，本地坐标采用的是`本地坐标系`，个人更喜欢叫`视角坐标系`。

`本地坐标系`的三个坐标轴的正方向分别是`左`、`上`、`前`。这里的`前`指视线正前方，`左`和`上`同理，不作过多解释了。

需要注意的是，`本地坐标`和`绝对坐标|相对坐标`是不能混用的。

## 4. 朝向

**朝向**主要是指实体的朝向。其数据类型是`Float`。

对于玩家而言朝向就是视线的方向，而对于一些没有视线的实体，就采用**默认朝向**。

实体的默认朝向是`水平向南`，写成数字就是`0.0f 0.0f`，后面讲到`NBT`时，还会细说`Rotation`的。

从这里就可以看出来了，朝向是由两个数字组成的。第一个叫`<y-rot>`，第二个叫`<x-rot>`，大家不要被这个x和y搞混了。只要记住一点，当出现表示朝向的一组数字时，第一个指的是水平的角度（简单来说就是左转或右转了多少度），第二个指的是竖直的角度（简单来说就是抬了或者降了多少度）。

我们还是通过例子来进行说明。例如`359.0f 90f`表示从`水平正南`顺时针转`359.0`度，并低头`90`度。这里的`359.0f`也可以写成`-1.0f`。

细心的朋友就看出来了：**水平方向**上，顺时针是正，逆时针是负，总共可以`360`度；**竖直方向**上，低头是正，抬头是负，总共可以转`180`度，也就是抬头和低头都不能超过`90`度。如果前面的你都记不住，就记这一段话好了。

# 第四章 选择器

本章是我认为的最需要细读的一章。因为许多人不能熟练运用指令实际上就是栽在了这一块。如果读者不想重蹈覆辙，应当认真看完这一章。

## 1. 什么是选择器

许多指令都要求指定玩家或者实体作为参数，这个参数就叫做选择器。选择器由两部分组成，第一部分指定了选择器的种类，第二部分指定了选择器的参数。例如：

    @a[gamemode=survival,team=red]

这里的`@a`就是**选择器的种类**，`[gamemode=survival,team=red]`就是**选择器参数**。注意区别`指令参数`和`选择器参数`。

在指令格式中，选择器以`<target>`和`<targets>`出现，前者表示这里**只能指定1个实体**，后者表示**可以指定多个实体**。

## 2. 选择器能干什么

选择器的作用就是指定实体。由于选择器有很多参数，因此可以比较具体地筛选出符合条件的实体，用于实现一些特定的功能。例如我们在序言中提到的那个所谓的"检测"，本质上就是对选择器的运用。

## 3. 选择器的使用范围

前面说了，选择器的作用是指定实体。因此只能指定在线的玩家和实体，对于不在线的玩家和假名，就不能够用选择器了。后面我们会讲到有特定的手段。

## 4. 选择器的种类

目前一共有5种选择器，分别是：

    @p - 最近的玩家
    @r - 随机的玩家
    @a - 所有玩家
    @e - 所有实体
    @s - 当前的指令执行者

## 5. 选择器的参数

    - 位置与区域 -

    x, y, z　　　　指定选择器的原点，只能使用绝对坐标