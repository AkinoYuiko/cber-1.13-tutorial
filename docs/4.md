# 第四章&emsp;选择器

本章是我认为的最需要细读的一章。因为许多人不能熟练运用指令实际上就是栽在了这一块。如果读者不想重蹈覆辙，应当认真看完这一章。

## 1. 什么是选择器

许多指令都要求指定玩家或者实体作为参数，这个参数就叫做选择器。选择器由两部分组成，第一部分指定了选择器的种类，第二部分指定了选择器的参数。例如：

    @a[gamemode=survival,team=red]

这里的`@a`就是**选择器的种类**，`[gamemode=survival,team=red]`就是**选择器参数**。注意区别`指令参数`和`选择器参数`。

在指令格式中，选择器以`<target>`和`<targets>`出现，前者表示这里**只能指定1个实体**，后者表示**可以指定多个实体**。

## 2. 选择器能干什么

选择器的作用就是指定实体。由于选择器有很多参数，因此可以比较具体地筛选出符合条件的实体，用于实现一些特定的功能。例如我们在序言中提到的那个所谓的"检测"，本质上就是对选择器的运用。

## 3. 选择器的使用范围

前面说了，选择器的作用是指定实体。因此只能指定在线的玩家和实体，对于不在线的玩家和假名，就不能够用选择器了。后面我们会讲到有特定的手段。

## 4. 选择器的种类

目前一共有5种选择器，分别是：

    @p - 最近的玩家
    @r - 随机的玩家
    @a - 所有玩家
    @e - 所有实体
    @s - 当前的指令执行者

以上是官方给出的解释，但是请大家抛开这些所谓的"最近"、"随机"的概念，稍后等列举完选择器参数后，让我们来重新认识选择器。

## 5. 选择器的参数

### 5.1 位置与空间

&emsp;`x=X`, `y=Y`, `z=Z` —— 决定选择器的原点，可以分开单独使用；没有列出来的，默认是**指令的执行位置**；这里的`X`, `Y`, `Z`是位置坐标，只能是**绝对坐标**。

&emsp;`dx=DX`, `dy=DY`, `dz=DZ` —— 从选择器的原点出发，向`x`, `y`, `z`的正方向的偏移量，形成一个**长方体范围**；这个偏移量也是`Double`类型的数；可以分开单独使用，此时，没有列出来的，默认是`0`。

&emsp;`distance=A..B` —— 距离选择器原点超过距离`A`而小于`B`的范围，这里的`A`和`B`都是`Double`类型的数，`A`或者`B`可以省略不写，但至少要出现其中一个。

&emsp;`y_rotation=A..B` —— 选取**水平**方向的视角在区间`[A,B]`的实体

&emsp;`x_rotation=A..B` —— 选取**竖直**方向的视角在区间`[A,B]`的实体


### 5.2 记分板相关

&emsp;`scores={obj1=A..B,obj2=C..D}` —— 分数符合`obj1`记分项在区间`[A,B]`，并且`obj2`记分项在区间`[C,D]`的实体会被选中

&emsp;`tag=TAG` —— 选取带有`TAG`这个标签的实体

&emsp;`team=TEAM` —— 选取`TEAM`这个队伍中的实体

&emsp;这里稍微说一下`team`这个参数，`team=`代表无队伍的实体，反之`team=!`代表有队伍的实体

### 5.3 玩家限定

&emsp;`level=A..B` —— 选取等级在区间`[A,B]`之间的玩家（非玩家实体没有等级这个属性）

&emsp;`gamemode=(survival|creative|adventure|spectator)` —— 选取对应模式的玩家（括号中按顺序依次是`生存|创造|冒险|旁观`）

### 5.4 杂项

&emsp;`type=TYPE` —— 选择类型为`TYPE`的实体，这里的`TYPE`必须是有效的实体类型，例如`player`, `creeper`等

&emsp;`name=NAME` —— 选取名为`NAME`的实体。考虑到现版本用的是`JSON`格式，建议优先使用`tag`。

&emsp;`nbt={...}` —— 选取符合`{...}`的`NBT`的实体，这部分比较复杂，在后面再讲，本章不作详细讲解。

&emsp;`limit=C` —— 选取的实体不超过`C`个，`C`为**正整数**。

&emsp;`sort=(arbitrary|nearest|furthest|random)` —— 决定选取顺序。当只能选取有限数量实体时，`sort`指定了哪些实体会被优选。

&emsp;&emsp;`arbitrary` - 不指定`sort`时的默认值。

&emsp;&emsp;`nearest` - 按距离排序，从符合所有条件的实体中，距离选择器原点最近的开始选。

&emsp;&emsp;`furthest` - 按距离排序，从符合所有条件的实体中，从距离选择器原点最远的开始选。

&emsp;&emsp;`random` - 随机排序。

## 6. 重新认识实体选择器 @e[...]

### 6.1 关于`@p`, `@a`, `@r`你需要知道的一些事

选择器在英文中的叫法叫`target selector`，我们习惯性翻译为`实体选择器`，简称`选择器`。

选择器的最一般写法是`@e[...]`，前面虽然列举了多种选择器，但实际上除了`@s`，都可以通过`@e`搭配相应的`选择器参数`来完成，因此选择器严格上来说只有两种。

这里写出不列举其他参数的情况下的默认等价情况。

    @p = @e[type=player,limit=1]     
    @a = @e[type=player]
    @r = @e[type=player,limit=1,sort=random]

请记住，这是不列举其他参数的情况。如果列举了其他参数呢？例如：

    @p[limit=2] = @a[limit=2] = @e[type=player,limit=2]
    @p[sort=furthest] = @a[limit=1,sort=furthest] = @e[type=player,limit=1,sort=furthest]
    @p[sort=random] = @a[limit=1,sort=random] = @e[type=player,limit=1,sort=random] = @r[] = @r

也就是说，`@p`, `@a`, `@r`特殊的实体选择器，由于选择器选玩家的操作比较常见，因此被单独拿了出来做出了特殊的选择器。但是并不意味着它们就不可以通过指定具体参数来"变成"另一种选择器。它们之间的界限没有那么严格。

但是，这里要特别指出，在当前版本，`@r`能且只能选中玩家，如果要在其他类型实体中随机选择，只能用`@e[sort=random,limit=XXX]`这种写法。

### 6.2 参数即条件

接下来，我们对前面那堆参数进行详细讲解。

我们说了，选择器参数是就是选择实体的条件，当一个选择器中列举了多个参数，也就是多个条件时，只有**符合全部条件**的实体会被选中。

&emsp;6.2.1 `distance`

`distance=A`和`distance=A..B`是两种写法，前者表示距离刚好为`A`，后者表示距离在`[A,B]`之间。在1.13早期快照中，这个区间是`(A,B)`。也就是说，过去你对自己使用`distance=0`这个参数是选不到自己的，转而使用`distance=...001`这类写法，也就是`distance=..0.001`。而现在， 你可以放心大胆使用`distance=0`了。

如果你想选**半径5以内**的实体，你可以写成`distance=..5`，反之如果要选半径5以外的实体，就是`distance=5..`，这个还是比较好理解的。

&emsp;6.2.2 `tag`, `type`, `team`

`tag`这个参数可以复写，例如`tag=A,tag=!B,tag=!C`，表示**拥有`A`这个标签，但不拥有`B`, `C`这两个标签**的实体；

与此类似的是`type`，但是有不一样的地方。你可以写`type=!minecraft:player,type=!minecraft:creeper`，来表示**既不是玩家也不是爬行者**的实体，但你不能写`type=minecraft:player,type=minecraft:pig`，因为一个实体**不可能既是玩家又是猪** <s>谁说不可能的？我给你列个表啊！</s>

`team`也是一样。一个实体在某一刻只能在一个确定的队伍中，或者不在队伍中，不可能同时在两个队伍中，因此你也不能写`team=A,team=B`这样的写法。

&emsp;6.2.3 `score`

`score`这个参数没有反选。如果硬要反选，可以通过`/execute unless entity @e[...]`这种手段，后面我们会讲的。

&emsp;6.2.4 `y_rotation`

我们前面讲过，水平正南是实体的默认朝向，此时记为`0.0f 0.0f`。

在`1.13`中，由于求余方式的问题，从玩家进入游戏开始，如果顺时针旋转的圈数多于逆时针旋转的圈数，则玩家的水平旋转角度的取值范围是`[0.0f,360.0f)`，反之是`(-360.0f,-0.0f]`。使用`/tp`等指令达到的效果除外。这个问题已在`18w31a`中修复。

但是，这并不影响`y_rotation`的使用，也就是说，就算水平旋转角是`-359.5f`，也依然可以通过`y_rotation=0..9.9`选中。

&emsp;6.2.5 `nbt={...}` 与 `/testfor`

这里不进行细说，但是要提到一个当前版本已经不存在的指令：`/testfor`，其指令格式是`/testfor <targets> <nbt>`

同理还有一个指令，在`1.13`以前是`/scoreboard players (add|remove|set) <targets> <objective> <score> <nbt>`，在`1.13`则是`/scoreboard players (add|remove|set) <targets> <objective> <score>`

对比可以看出来，由于选择器中支持了`nbt={...}`这样的写法，因此已经不需要将`<nbt>`单独作为一个参数放在指令尾部了，这是一个很不合理的写法。

这就是为什么`/testfor`彻底失去了它的意义。过去人们使用它，很大程度上就是通过`NBT`配合选择器来进行更具体地筛选。

个人比较反感"检测....."这样的表述，因为归结起来它就是对`选择器`和`NBT`的运用。与其叫做`检测`，不如叫`筛选`更为合理。

### 6.3 执行者选择器`@s`

这里特别拿`@s`出来讲。因为`@s`是要独立于`@e`的，为什么这么说呢？这要从`@s`的起源说起。

我们知道很多情况下，尤其是在使用`/execute`的情况下，经常要选择执行者自己，过去没有`@s`这个选择器的时候，人们最常用的做法是给自己加一个标签或者设置一个分数，然后再通过相关的`选择器参数`来选取自己。但在多人的时候这个也不太好用，于是大家又限制了一个条件`r=0,c=1`即现在的`distance=0,limit=1`。

但是，`@e[limit=1,distance=0]`和`@s`并不等价的。更何况到了`1.13`以后，指令的执行者和执行位置实现了更为彻底的独立。

在这个前提下，`@s`应运而生。

这里需要指出的是，我们可以通过`/execute as ...`来改变执行者，因此跟在 `as ...`后面的`@s`并不一定是最初的执行者，这一点希望读者牢记。